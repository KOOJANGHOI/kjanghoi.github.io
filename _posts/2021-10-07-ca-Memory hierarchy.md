---
layout: post
title: 5.Memory hierarchy
subtitle: 
categories: [Computer Architecture]
tags: [ComputerScience]
---

### 1.서론
- 지역성(locality)의 원리와 메모리를 메모리 계층 구조(memory hierarchy)로 구현하는 이유
- 무제한의 빠른 메모리를 갖고 있는 듯한 환상을 만들어 프로그래머를 돕고자 함. 이 환상이 실제로 어떻게 만들어지는가

#### Principle of locality
￼
![1.1](/assets/images/ca/5.1.png)

#### 프로그램에서의 지역성
- Temporal locality
    - 대부분의 프로그램들이 순환문 구문을 가지고있고, 순환문은 명령어와 데이터에 반복적으로 접근하므로 상당히 큰 시간적 지역성을 보여준다.
- Spatial locality
    - 명령어들은 대게 순차적으로 접근되기때문에 큰 공간적 지역성을 보여준다. 
    - 데이터 접근에도 그렇다. 예를들어 배열이나 레코드의 요소들에 접근할 때는 대게 큰 공간적 지역성을 갖는다.

#### 메모리 계층구조
- 사용자에게 가장 빠른 메모리가 갖고있는 접근속도를 제공하면서 동시에 가장 싼 기술로 최대한 큰 메모리 용량을 제공하는것
- 최근에 접근했던 데이터들을 프로세서 가까이 적재함으로써 시간적 지역성을 이용한다. 
- 또한 메모리의 상위계층으로 필요한 데이터 뿐만 아니라 이와 인접한 다량의 데이터들로 이루어진 블록들을 옮김으로써 공간적 지역성을 이용한다.
- 프로세서가 요구한 데이터가 상위계층의 어떤 블록에 있을때 적중(hit) 아닐때 실패(miss) 라고 한다.
- 적중률이 충분히 크면, 메모리 접근속도는 최상위 계층과 비슷하고 크기는 최하위 계층 메모리와 같아진다.

![1.1](/assets/images/ca/5.2.png)

![1.1](/assets/images/ca/5.3.png)

#### 메모리 계층구조의 비유
- 캐시 : 책상
- 상위 메모리 : 책장
- 하위 메모리1 : 단과대 도서관
- 하위 메모리2 : 학교 도서관

### 2.메모리 기술
- 오늘날 메모리 계층구조의 네가지 기술 : DRAM, SRAM, 플래시 디스크, 자기 디스크

![1.1](/assets/images/ca/5.4.png)

![1.1](/assets/images/ca/5.5.png)

#### SRAM
- 읽거나 쓰기를 제공하는 포트가 일반적으로 하나 있는 단순한 집적회로
- 리프레시가 필요 없으므로 접근시간은 사이클 시간과 거의 같도록 빠르다
- 읽을때 데이터가 변하지 않도록 하기위해서 비트당 6~8개의 트랜지스터를 사용한다
- 전력이 공급되는 한 값이 무한히 유지된다.

![1.1](/assets/images/ca/5.6.png)

#### DRAM
- 커페시터에 전하를 저장하기때문에 무한히 저장할 수 없어 리프레시가 필요하다
- 저장된 비트 하나당 하나의 트렌지스터만 사용하므로 집적도가 높아 값이 싸다

![1.1](/assets/images/ca/5.7.png)

![1.1](/assets/images/ca/5.8.png)

### 3.캐시의 기본
- Cache : a safe place for hiding or storing things
    - 캐시는 1960년대 초반 연구용 컴퓨터에서 처음 등장하였고, 같은 60년대 후반에 실제 시스템에서 사용되기 시작하였다. 오늘날에는 서버 기종에서 저잔력 임베디드 프로세서에 이르기까지 사실상 모든 범용 컴퓨터가 캐시를 이용하고있다.
    - 캐시는 예측기법을 사용하는 가장 중요한 예라고 할 수 있다. 지역성의 원칙을 이용해서 메모리 상위계층에서 필요한 데이터를 찾는다. 상위계층에서 예측이 틀렸을 경우에는 하위계층에서 적합한 데이터를 찾을 수 있는 기법을 제공한다. 현대 컴퓨터의 캐시 예측 적중률은 95% 이상이다.
- 캐시의 구조: 데이터가 캐시에 있는지 어떻게 알 수 있을까? 그리고 알 수 있다면 어떻게 찾을 수 있는가 
- 캐시의 읽기, 쓰기, 실패 처리

#### Direct mapped cache

![1.1](/assets/images/ca/5.9.png)

![1.1](/assets/images/ca/5.10.png)
￼
#### 캐시 실패의 처리

![1.1](/assets/images/ca/5.11.png)
￼
제어유닛은 실패를 탐지해야 하며, 메모리 또는 하위 수준의 캐시로부터 데이터를 가져와서 실패를 처리해야한다.
만약 캐시내에 원하는 데이터가 존재하면 컴퓨터는 아무 일도 없는것처럼 데이터를 사용할 수 있다.

캐시 실패 발생시에는 임시 레지스터와 프로그래머에게 보이는 레지스터의 내용을 그대로 유지한채 메모리로부터 데이터가 오기를 기다리면서 전체 시스템을 지연시킨다. 더 정교한 프로세서는 캐시 실패 처리를 기다리면서 명령어를 실행시킬 수 있다.

#### 쓰기의 처리
쓰기는 읽기보다 복잡하다. 데이터를 캐시에만 쓰고 메인메모리에는 쓰지 않을경우, 메인메모리는 캐시와 다른 값을 갖게된다.
이 경우에 캐시와 메인메모리는 불일치(inconsistent) 한다고 말한다.

**즉시 쓰기 (write through)**

- 항상 데이터를 메모리와 캐시에 같이 쓴다. 이 방식은 가장 쉽지만 설게를 잘 한다고 하더라도 좋은 성능을 제공하기 어렵다.
- 쓰기 시간이 오래 걸리기 때문에 최소한 100개의 클럭 사이클이 필요하고, 이는 프로세서의 성능을 크게 저하시킨다.

**쓰기 버퍼 (write buffer)**

- 쓰기 버퍼는 메모리에 쓰이기 위해 기다리는 동안 데이터를 저장한다. 데이터를 캐시와 쓰기버퍼에 쓰고 난 후 프로세서는 수행을 계속 할 수 있다. 메인메모리에 쓰기를 완료하고나면 쓰기 버퍼에 있는 엔트리는 다시 비게된다.
- 쓰기 신호가 발생되는 속도와 메모리 시스템이 쓰기를 받아들이는 속도 차이가 있어 오버헤드 (지연)이 존재한다.
- 프로세스가 쓰기 처리를 하려고 할때 쓰기 버퍼가 모두 차 있으면 쓰기 버퍼에 빈 공간이 생길 때까지 멈춰있어야만 한다.

**나중 쓰기 (write back)**

- 쓰기가 발생했을때 새로운 값은 캐시 내 블록에만 쓴다. 그러다가 나중에 캐시에서 방출될 때 쓰기에 의해 내용이 바뀐 블록이면 메모리 계층구조의 더 낮은 계층에 써진다

**쓰기 할당 (write allocate)**

![1.1](/assets/images/ca/5.12.png)
￼
### 4.캐시 성능의 측정 및 향상
- 캐시 내 블록을 배치하는 방법
- 교체되는 블록을 선택하는 방법
- 다단계의 캐시 구성

#### 직접 사상 (direct mapped)
- 가장 단순한 배치방법
- 메모리 블록을 캐시에 넣을때 각 블록이 캐시의 딱 한 곳에만 들어갈 수 있다.

#### 완전 연관 (fully associative)
- 블록이 캐시 내의 어느곳에나 위치할 수 있는 방식
- 주어진 블록을 찾기위해서는 캐시내의 모든 엔트리를 검색하야한다. 실제로는 각 캐시 엔트리와 연결된 비교기를 이용하여 병렬로 검색한다.
- 하드웨어 비용을 크게 증가시키므로, 캐시가 블록을 적게 갖는 방식에서 유용하다.

#### 집합 연관 (set associative)
- 한 블록이 들어갈 수 있는 자리의 갯수가 고정되어 있는 방식
- 각 블록당 n개의 배치 가능한 위치를 갖는 집합 연관 캐시를 n-way 집합 연관 캐시라고 부른다.
- 탐색은 집합 내의 블록을 검색하면 되어 효율적이고, 대게 실패율이 줄어드는 장점이 있다. 반면 적중시간이 증가하는것이 단점이다.

![1.1](/assets/images/ca/5.13.png)

![1.1](/assets/images/ca/5.14.png)

#### 다단계의 캐시 구성
- 프로세서의 빠른 클럭 속도와 상대적으로 느린 DRAM의 접근시간 사이의 차이를 더욱 줄이기 위해, 고성능 마이크로 프로세서들은 캐시를 한단계 더 사용한다. 이 2차 캐시는 주로 마이크로 프로세서에 내장되어있으며, 1차 캐시에서 실패가 발생할때 접근된다. 2차캐시가 원하는 데이터를 갖고있으면 실패손실은 2차캐시의 접근시간이 되며, 이 값은 메인메모리의 접근시간보다 훨씬 작다.
- 1차 캐시는 크기를 작게하고 실패손실을 줄이기 위해 블록의 크기가 작다. 반면 2차 캐시는 접근시간이 덜 중요하기때문에 크기가 더 크고 실패율을 줄이는 데 집중해야하므로 높은 연관 정도가 사용된다.
- 제한된 실리콘의 크기와 고속 클럭 속도를 달성하기 위해서는 크기가 큰 1차 캐시를 사용할 수 없다는것을 파악하게되면서 2차 캐시가 일반화 되었다. 1차 캐시보다 10배 또는 그 이상 더 큰 2차 캐시는 1차 캐시에서 실패가 발생한 많은 접근을 처리할 수 있다. 이러한 경우 실패 손실은 2차 캐시 접근시간 (일반적으로 10 사이클 이내)이 된다. (메모리 접근시간은 일반적으로 100사이클 이상이다)

![1.1](/assets/images/ca/5.15.png)

### 5.6 가상머신

![1.1](/assets/images/ca/5.16.png)

![1.1](/assets/images/ca/5.17.png)


